<p style="text-align: center;"><span style="font-size: 18pt;">[译]Vulkan教程(06)验证层</span></p>
<h1>What are validation layers? 什么是验证层？</h1>
<p><span style="color: #888888;">The Vulkan API is designed around the idea of minimal driver overhead and one of the manifestations of that goal is that there is very limited error checking in the API by default. Even mistakes as simple as setting enumerations to incorrect values or passing null pointers to required parameters are generally not explicitly handled and will simply result in crashes or undefined behavior. Because Vulkan requires you to be very explicit about everything you're doing, it's easy to make many small mistakes like using a new GPU feature and forgetting to request it at logical device creation time.</span></p>
<p>Vulkan API的核心设计思想是最小化driver开销，其表现之一就是，API本身的错误检查很少。设置错误的枚举值，向必选参数传入空指针，即使是这样简单的错误，也不会被显式地处理，而只是简单地崩溃，或做出未定义的行为。因为Vulkan要求你对你做的所有事都清楚明白，很容易犯各种小错误，例如，想使用新GPU特性，却忘记在逻辑设备创建时请求它。</p>
<p><span style="color: #888888;">However, that doesn't mean that these checks can't be added to the API. Vulkan introduces an elegant system for this known as&nbsp;<em>validation layers</em>. Validation layers are optional components that hook into Vulkan function calls to apply additional operations. Common operations in validation layers are:</span></p>
<ul>
<li><span style="color: #888888;">Checking the values of parameters against the specification to detect misuse</span></li>
<li><span style="color: #888888;">Tracking creation and destruction of objects to find resource leaks</span></li>
<li><span style="color: #888888;">Checking thread safety by tracking the threads that calls originate from</span></li>
<li><span style="color: #888888;">Logging every call and its parameters to the standard output</span></li>
<li><span style="color: #888888;">Tracing Vulkan calls for profiling and replaying</span></li>
</ul>
<p align="left">但是，这不意味着这些检查无法加入到API。Vulkan引入了一个优雅的系统，即<em>验证层</em>。验证层是可选组件，他挂钩进Vulkan函数调用，以实施额外操作。验证层的常见操作有：</p>
<ul>
<li>根据说明书检查参数值，以检测误用</li>
<li>跟踪对象的创建和销毁过程，以查找资源泄漏</li>
<li>通过追踪线程调用源头来检查线程安全性</li>
<li>将所有调用及其参数保存到标准输出</li>
<li>追踪Vulkan调用，用于剖析和重演</li>
</ul>
<p><span style="color: #888888;">Here's an example of what the implementation of a function in a diagnostics validation layer could look like:</span></p>
<p>下面展示了诊断验证层的函数可能的样子：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #000000;">VkResult vkCreateInstance(
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">const</span> VkInstanceCreateInfo*<span style="color: #000000;"> pCreateInfo,
</span><span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">const</span> VkAllocationCallbacks*<span style="color: #000000;"> pAllocator,
</span><span style="color: #008080;"> 4</span>     VkInstance*<span style="color: #000000;"> instance) {
</span><span style="color: #008080;"> 5</span>  
<span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">if</span> (pCreateInfo == nullptr || instance ==<span style="color: #000000;"> nullptr) {
</span><span style="color: #008080;"> 7</span>         log(<span style="color: #800000;">"</span><span style="color: #800000;">Null pointer passed to required parameter!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> VK_ERROR_INITIALIZATION_FAILED;
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">10</span>  
<span style="color: #008080;">11</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> real_vkCreateInstance(pCreateInfo, pAllocator, instance);
</span><span style="color: #008080;">12</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">These validation layers can be freely stacked to include all the debugging functionality that you're interested in. You can simply enable validation layers for debug builds and completely disable them for release builds, which gives you the best of both worlds!</span></p>
<p>这些验证层可以被栈入进各种你感兴趣的调试功能。你可以简单地在debug阶段启用验证层，在release阶段彻底禁用它们。这对开发和应用世界都是最好的！</p>
<p><span style="color: #888888;">Vulkan does not come with any validation layers built-in, but the LunarG Vulkan SDK provides a nice set of layers that check for common errors. They're also completely&nbsp;<a href="https://github.com/KhronosGroup/Vulkan-ValidationLayers"><span style="color: #888888;">open source</span></a>, so you can check which kind of mistakes they check for and contribute. Using the validation layers is the best way to avoid your application breaking on different drivers by accidentally relying on undefined behavior.</span></p>
<p>Vulkan没有任何内建的验证层，但是LunarG的Vulkan SDK提供了一个不错的验证层集合，它们能够检查常见错误。它们也是完全开源的，所以你可以看看它们检查哪种错误，并贡献自己的才智。你的app在不同的driver上可能因为意外的未定义行为而中止，使用这些验证层是避免这一问题的最好方法。</p>
<p><span style="color: #888888;">Validation layers can only be used if they have been installed onto the system. For example, the LunarG validation layers are only available on PCs with the Vulkan SDK installed.</span></p>
<p>验证层只能在被安装到系统上后才能使用。例如，只有安装了Vulkan SDK，LunarG的验证层才能在你的PC上用。</p>
<p><span style="color: #888888;">There were formerly two different types of validation layers in Vulkan: instance and device specific. The idea was that instance layers would only check calls related to global Vulkan objects like instances, and device specific layers would only check calls related to a specific GPU. Device specific layers have now been deprecated, which means that instance validation layers apply to all Vulkan calls. The specification document still recommends that you enable validation layers at device level as well for compatibility, which is required by some implementations. We'll simply specify the same layers as the instance at logical device level, which we'll see&nbsp;<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Logical_device_and_queues"><span style="color: #888888;">later on</span></a>.</span></p>
<p>以前Vulkan中有两种不同类型的验证层：针对instance的和针对device的。Instance层只检查与全局Vulkan对象（例如instance）相关的调用；device层只检查与特定CPU相关的调用。Device层现在已经被废弃了，这意味着instance验证层对所有Vulkan调用都有用。为了兼容某些实现，说明书里仍旧推荐你启用device水平的验证层。我们将简单地标明一个层同时属于instance水平和逻辑device水平，详见后续。</p>
<h1>Using validation layers 使用验证层</h1>
<p><span style="color: #888888;">In this section we'll see how to enable the standard diagnostics layers provided by the Vulkan SDK. Just like extensions, validation layers need to be enabled by specifying their name. All of the useful standard validation is bundled into a layer included in the SDK that is known as&nbsp;<code>VK_LAYER_KHRONOS_validation</code>.</span></p>
<p>这一节我们看看如何启用Vulkan SDK提供的标准诊断层。像扩展一样，验证层需要通过标明它们的名字来启用。所有有用的标准验证都被绑进了这个SDK里的被称为<code>VK_LAYER_KHRONOS_validation</code>的层。</p>
<p><span style="color: #888888;">Let's first add two configuration variables to the program to specify the layers to enable and whether to enable them or not. I've chosen to base that value on whether the program is being compiled in debug mode or not. The&nbsp;<code>NDEBUG</code>&nbsp;macro is part of the C++ standard and means "not debug".</span></p>
<p>我们首先添加2个配置变量，标明要启用的层，以及是否启用它们。我已经选择让这个值基于程序的编译模式是不是debug。宏<code>NDEBUG</code>&nbsp;是C++标准的一部分，意思是&ldquo;不是debug&rdquo;。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> WIDTH = <span style="color: #800080;">800</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> HEIGHT = <span style="color: #800080;">600</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 3</span>  
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">const</span> std::vector&lt;<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>*&gt; validationLayers =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 5</span>     <span style="color: #800000;">"</span><span style="color: #800000;">VK_LAYER_KHRONOS_validation</span><span style="color: #800000;">"</span>
<span style="color: #008080;"> 6</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 7</span>  
<span style="color: #008080;"> 8</span> <span style="color: #000000;">#ifdef NDEBUG
</span><span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> enableValidationLayers = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">10</span> <span style="color: #0000ff;">#else</span>
<span style="color: #008080;">11</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> enableValidationLayers = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
</span><span style="color: #008080;">12</span> <span style="color: #0000ff;">#endif</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">We'll add a new function&nbsp;<code>checkValidationLayerSupport</code>&nbsp;that checks if all of the requested layers are available. First list all of the available layers using the&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkEnumerateInstanceLayerProperties.html"><span style="color: #888888;"><code>vkEnumerateInstanceLayerProperties</code></span></a>&nbsp;function. Its usage is identical to that of&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkEnumerateInstanceExtensionProperties.html"><span style="color: #888888;"><code>vkEnumerateInstanceExtensionProperties</code></span></a>&nbsp;which was discussed in the instance creation chapter.</span></p>
<p>我们将添加一个新函数<code>checkValidationLayerSupport</code>&nbsp;，它检查是否所有请求的层都可用。首先用<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkEnumerateInstanceLayerProperties.html"><code>vkEnumerateInstanceLayerProperties</code></a>&nbsp;函数列出所有可以用的层，它的用法和之前的创建instance章节的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>&nbsp;函数相同。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">bool</span><span style="color: #000000;"> checkValidationLayerSupport() {
</span><span style="color: #008080;">2</span> <span style="color: #000000;">    uint32_t layerCount;
</span><span style="color: #008080;">3</span>     vkEnumerateInstanceLayerProperties(&amp;<span style="color: #000000;">layerCount, nullptr);
</span><span style="color: #008080;">4</span>  
<span style="color: #008080;">5</span>     std::vector&lt;VkLayerProperties&gt;<span style="color: #000000;"> availableLayers(layerCount);
</span><span style="color: #008080;">6</span>     vkEnumerateInstanceLayerProperties(&amp;<span style="color: #000000;">layerCount, availableLayers.data());
</span><span style="color: #008080;">7</span>  
<span style="color: #008080;">8</span>     <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">9</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">Next, check if all of the layers in&nbsp;<code>validationLayers</code>&nbsp;exist in the&nbsp;<code>availableLayers</code>&nbsp;list. You may need to include&nbsp;<code>&lt;cstring&gt;</code>&nbsp;for&nbsp;<code>strcmp</code>.</span></p>
<p>下一步，检查是否<code>validationLayers</code>&nbsp;中所有的层都存在于<code>availableLayers</code>&nbsp;列表中。你可能需要include一下<code>&lt;cstring&gt;</code>，以使用<code>strcmp</code>函数。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>*<span style="color: #000000;"> layerName : validationLayers) {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">bool</span> layerFound = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 3</span>  
<span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">const</span> auto&amp;<span style="color: #000000;"> layerProperties : availableLayers) {
</span><span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">if</span> (strcmp(layerName, layerProperties.layerName) == <span style="color: #800080;">0</span><span style="color: #000000;">) {
</span><span style="color: #008080;"> 6</span>             layerFound = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 7</span>             <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">10</span>  
<span style="color: #008080;">11</span>     <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">layerFound) {
</span><span style="color: #008080;">12</span>         <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">13</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">14</span> <span style="color: #000000;">}
</span><span style="color: #008080;">15</span>  
<span style="color: #008080;">16</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">We can now use this function in&nbsp;<code>createInstance</code>:</span></p>
<p>现在我们可以在<code>createInstance</code>中使用这个函数了：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> createInstance() {
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">if</span> (enableValidationLayers &amp;&amp; !<span style="color: #000000;">checkValidationLayerSupport()) {
</span><span style="color: #008080;">3</span>         <span style="color: #0000ff;">throw</span> std::runtime_error(<span style="color: #800000;">"</span><span style="color: #800000;">validation layers requested, but not available!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">4</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">5</span>  
<span style="color: #008080;">6</span> <span style="color: #000000;">    ...
</span><span style="color: #008080;">7</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">Now run the program in debug mode and ensure that the error does not occur. If it does, then have a look at the FAQ.</span></p>
<p>现在在debug模式下运行现在，确保没有错误出现。如果出现错误，就看一下FAQ。</p>
<p><span style="color: #888888;">Finally, modify the&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkInstanceCreateInfo.html"><span style="color: #888888;"><code>VkInstanceCreateInfo</code></span></a>&nbsp;struct instantiation to include the validation layer names if they are enabled:</span></p>
<p>最后，修改<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>&nbsp;结构体，如果启用了验证层，就将它们的名字包含进来：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (enableValidationLayers) {
</span><span style="color: #008080;">2</span>     createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;<span style="color: #000000;">(validationLayers.size());
</span><span style="color: #008080;">3</span>     createInfo.ppEnabledLayerNames =<span style="color: #000000;"> validationLayers.data();
</span><span style="color: #008080;">4</span> } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
</span><span style="color: #008080;">5</span>     createInfo.enabledLayerCount = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">6</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">If the check was successful then&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html"><span style="color: #888888;"><code>vkCreateInstance</code></span></a>&nbsp;should not ever return a&nbsp;<code>VK_ERROR_LAYER_NOT_PRESENT</code>&nbsp;error, but you should run the program to make sure.</span></p>
<p>如果if判断成功，那么<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>&nbsp;应该就不会再返回<code>VK_ERROR_LAYER_NOT_PRESENT</code>&nbsp;错误，但是你应该运行程序以确保之。</p>
<h1>Message callback 消息回调</h1>
<p><span style="color: #888888;">Unfortunately just enabling the layers doesn't help much, because they currently have no way to relay the debug messages back to our program. To receive those messages we have to set up a debug messenger with a callback, which requires the&nbsp;<code>VK_EXT_debug_utils</code>&nbsp;extension.</span></p>
<p>不幸的是，仅仅启用层，并没有什么帮助，因为它们现在没办法将调试消息转回给程序。为了接收这些消息，我们不得不用回调设置一个debug信使，这就要使用<code>VK_EXT_debug_utils</code>&nbsp;扩展。</p>
<p><span style="color: #888888;">We'll first create a&nbsp;<code>getRequiredExtensions</code>&nbsp;function that will return the required list of extensions based on whether validation layers are enabled or not:</span></p>
<p>我们首先创建一个<code>getRequiredExtensions</code>&nbsp;函数，它将依据验证层是否被启用，返回请求的扩展的列表：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> std::vector&lt;<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>*&gt;<span style="color: #000000;"> getRequiredExtensions() {
</span><span style="color: #008080;"> 2</span>     uint32_t glfwExtensionCount = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>**<span style="color: #000000;"> glfwExtensions;
</span><span style="color: #008080;"> 4</span>     glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;<span style="color: #000000;">glfwExtensionCount);
</span><span style="color: #008080;"> 5</span>  
<span style="color: #008080;"> 6</span>     std::vector&lt;<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>*&gt; extensions(glfwExtensions, glfwExtensions +<span style="color: #000000;"> glfwExtensionCount);
</span><span style="color: #008080;"> 7</span>  
<span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">if</span><span style="color: #000000;"> (enableValidationLayers) {
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">        extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
</span><span style="color: #008080;">10</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">11</span>  
<span style="color: #008080;">12</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> extensions;
</span><span style="color: #008080;">13</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">The extensions specified by GLFW are always required, but the debug messenger extension is conditionally added. Note that I've used the&nbsp;<code>VK_EXT_DEBUG_UTILS_EXTENSION_NAME</code>&nbsp;macro here which is equal to the literal string "VK_EXT_debug_utils". Using this macro lets you avoid typos.</span></p>
<p>用GLFW标明的扩展，总是要用到，但是debug信使扩展是在一定条件下太会添加的。注意，这里我用<code>VK_EXT_DEBUG_UTILS_EXTENSION_NAME</code>&nbsp;宏，等于用字符串"VK_EXT_debug_utils"。用这个宏让你避免打字了。</p>
<p><span style="color: #888888;">We can now use this function in&nbsp;<code>createInstance</code>:</span></p>
<p>现在我们可以在<code>createInstance</code>中用这个函数了：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> auto extensions =<span style="color: #000000;"> getRequiredExtensions();
</span><span style="color: #008080;">2</span> createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;<span style="color: #000000;">(extensions.size());
</span><span style="color: #008080;">3</span> createInfo.ppEnabledExtensionNames = extensions.data();</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">Run the program to make sure you don't receive a&nbsp;<code>VK_ERROR_EXTENSION_NOT_PRESENT</code>&nbsp;error. We don't really need to check for the existence of this extension, because it should be implied by the availability of the validation layers.</span></p>
<p>运行程序，确保你没有收到<code>VK_ERROR_EXTENSION_NOT_PRESENT</code>&nbsp;错误。其实我们并不需要检查这个扩展的存在性，因为这已经被验证层的可用而暗示出了。</p>
<p><span style="color: #888888;">Now let's see what a debug callback function looks like. Add a new static member function called&nbsp;<code>debugCallback</code>with the&nbsp;<code>PFN_vkDebugUtilsMessengerCallbackEXT</code>&nbsp;prototype. The&nbsp;<code>VKAPI_ATTR</code>&nbsp;and&nbsp;<code>VKAPI_CALL</code>&nbsp;ensure that the function has the right signature for Vulkan to call it.</span></p>
<p>现在我们看看debug回调函数长什么样。添加一个新的静态成员函数<code>debugCallback</code>，以<code>PFN_vkDebugUtilsMessengerCallbackEXT</code>&nbsp;为原型。<code>VKAPI_ATTR</code>和<code>VKAPI_CALL</code>确保函数有正确的签名，以供Vulkan调用。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">    VkDebugUtilsMessageTypeFlagsEXT messageType,
</span><span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">const</span> VkDebugUtilsMessengerCallbackDataEXT*<span style="color: #000000;"> pCallbackData,
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">void</span>*<span style="color: #000000;"> pUserData) {
</span><span style="color: #008080;"> 6</span>  
<span style="color: #008080;"> 7</span>     std::cerr &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">validation layer: </span><span style="color: #800000;">"</span> &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt;<span style="color: #000000;"> std::endl;
</span><span style="color: #008080;"> 8</span>  
<span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> VK_FALSE;
</span><span style="color: #008080;">10</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">The first parameter specifies the severity of the message, which is one of the following flags:</span></p>
<ul>
<li><span style="color: #888888;"><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT</code>: Diagnostic message</span></li>
<li><span style="color: #888888;"><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT</code>: Informational message like the creation of a resource</span></li>
<li><span style="color: #888888;"><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT</code>: Message about behavior that is not necessarily an error, but very likely a bug in your application</span></li>
<li><span style="color: #888888;"><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT</code>: Message about behavior that is invalid and may cause crashes</span></li>
</ul>
<p align="left">第一个参数标明消息的严重性，具体如下：</p>
<ul>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT</code><code>：</code>诊断信息</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT</code>：例如创建资源这种消息</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT</code>：关于不像是错误，更像是app里的bug的行为的消息</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT</code>：关于无效且可能造成崩溃的行为的消息</li>
</ul>
<p><span style="color: #888888;">The values of this enumeration are set up in such a way that you can use a comparison operation to check if a message is equal or worse compared to some level of severity, for example:</span></p>
<p>这些枚举值是这样设计的：你可以用比较操作来检查一个消息是等于某个严重等级，还是更糟糕。例如：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span> (messageSeverity &gt;=<span style="color: #000000;"> VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
</span><span style="color: #008080;">2</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> Message is important enough to show</span>
<span style="color: #008080;">3</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">The&nbsp;<code>messageType</code>&nbsp;parameter can have the following values:</span></p>
<ul>
<li><span style="color: #888888;"><code>VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT</code>: Some event has happened that is unrelated to the specification or performance</span></li>
<li><span style="color: #888888;"><code>VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT</code>: Something has happened that violates the specification or indicates a possible mistake</span></li>
<li><span style="color: #888888;"><code>VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT</code>: Potential non-optimal use of Vulkan</span></li>
</ul>
<p align="left"><code>messageType</code>&nbsp;<code>参数可能的值如下：</code><code></code></p>
<ul>
<li><code>VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT</code>：与说明书或性能无关的事件发生了</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT</code>：违反说明书或者表明可能有错误的事件发生了</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT</code>：潜在的不够理想的运用Vulkan</li>
</ul>
<p><span style="color: #888888;">The&nbsp;<code>pCallbackData</code>&nbsp;parameter refers to a&nbsp;<code>VkDebugUtilsMessengerCallbackDataEXT</code>&nbsp;struct containing the details of the message itself, with the most important members being:</span></p>
<ul>
<li><span style="color: #888888;"><code>pMessage</code>: The debug message as a null-terminated string</span></li>
<li><span style="color: #888888;"><code>pObjects</code>: Array of Vulkan object handles related to the message</span></li>
<li><span style="color: #888888;"><code>objectCount</code>: Number of objects in array</span></li>
</ul>
<p>参数<code>pCallbackData</code>&nbsp;指向一个<code>VkDebugUtilsMessengerCallbackDataEXT</code>&nbsp;结构体，它包含消息的细节，其最重要的成员是：</p>
<ul>
<li><code>pMessage</code>：以\0结尾的字符串</li>
<li><code>pObjects</code>：处理相关消息的Vulkan对象的数组</li>
<li><code>objectCount</code>：对象数组的长度</li>
</ul>
<p><span style="color: #888888;">Finally, the&nbsp;<code>pUserData</code>&nbsp;parameter contains a pointer that was specified during the setup of the callback and allows you to pass your own data to it.</span></p>
<p>最后，参数<code>pUserData</code>&nbsp;包含在设置回调函数的指针，允许你传入自己的数据。</p>
<p><span style="color: #888888;">The callback returns a boolean that indicates if the Vulkan call that triggered the validation layer message should be aborted. If the callback returns true, then the call is aborted with the&nbsp;<code>VK_ERROR_VALIDATION_FAILED_EXT</code>&nbsp;error. This is normally only used to test the validation layers themselves, so you should always return&nbsp;<code>VK_FALSE</code>.</span></p>
<p>回调函数返回一个bool值，表明触发了验证层消息的Vulkan调用，是否应该被中止。如果返回true，那么调用就被中止，给出<code>VK_ERROR_VALIDATION_FAILED_EXT</code>&nbsp;错误。这一般仅用于测试验证层，所以你应该永远让它返回<code>VK_FALSE</code>。</p>
<p><span style="color: #888888;">All that remains now is telling Vulkan about the callback function. Perhaps somewhat surprisingly, even the debug callback in Vulkan is managed with a handle that needs to be explicitly created and destroyed. Such a callback is part of a&nbsp;<em>debug messenger</em>&nbsp;and you can have as many of them as you want. Add a class member for this handle right under&nbsp;<code>instance</code>:</span></p>
<p>剩下的就是告诉Vulkan，回调函数是谁。这可能有点惊人，Vulkan中，即使debug回调函数也受一个句柄管理，这个句柄需要被显式地创建和销毁。这样的回调函数是<em>debug</em><em>信使</em>的一部分，而且你想要多少都可以。在<code>instance</code>之后为这个句柄添加一个成员：</p>
<pre><span style="color: #888888;">VkDebugUtilsMessengerEXT<code> debugMessenger;</code></span></pre>
<p>Now add a function&nbsp;<code>setupDebugMessenger</code>&nbsp;to be called from&nbsp;<code>initVulkan</code>&nbsp;right after&nbsp;<code>createInstance</code>:</p>
<p>现在添加<code>setupDebugMessenger</code>&nbsp;函数，在<code>initVulkan</code>&nbsp;中继<code>createInstance</code>之后调用它：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> initVulkan() {
</span><span style="color: #008080;">2</span> <span style="color: #000000;">    createInstance();
</span><span style="color: #008080;">3</span> <span style="color: #000000;">    setupDebugMessenger();
</span><span style="color: #008080;">4</span> <span style="color: #000000;">}
</span><span style="color: #008080;">5</span>  
<span style="color: #008080;">6</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setupDebugMessenger() {
</span><span style="color: #008080;">7</span>     <span style="color: #0000ff;">if</span> (!enableValidationLayers) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">8</span>  
<span style="color: #008080;">9</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">We'll need to fill in a structure with details about the messenger and its callback:</span></p>
<p>我们需要给一个struct填入信息（关于信使及其回调函数）：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> VkDebugUtilsMessengerCreateInfoEXT createInfo =<span style="color: #000000;"> {};
</span><span style="color: #008080;">2</span> createInfo.sType =<span style="color: #000000;"> VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
</span><span style="color: #008080;">3</span> createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |<span style="color: #000000;"> VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
</span><span style="color: #008080;">4</span> createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |<span style="color: #000000;"> VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
</span><span style="color: #008080;">5</span> createInfo.pfnUserCallback =<span style="color: #000000;"> debugCallback;
</span><span style="color: #008080;">6</span> createInfo.pUserData = nullptr; <span style="color: #008000;">//</span><span style="color: #008000;"> Optional</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">The&nbsp;<code>messageSeverity</code>&nbsp;field allows you to specify all the types of severities you would like your callback to be called for. I've specified all types except for&nbsp;<code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT</code>&nbsp;here to receive notifications about possible problems while leaving out verbose general debug info.</span></p>
<p>字段<code>messageSeverity</code>&nbsp;允许你标明所有你想让你的回调函数响应的严重性类型。我标明了除<code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT</code>&nbsp;外的所有类型，以接收可能的问题的提醒，且不接收冗长的debug信息。</p>
<p><span style="color: #888888;">Similarly the&nbsp;<code>messageType</code>&nbsp;field lets you filter which types of messages your callback is notified about. I've simply enabled all types here. You can always disable some if they're not useful to you.</span></p>
<p>类似的，<code>messageType</code>&nbsp;字段让你过滤掉你不想让回调函数被通知到的消息类型。我简单地启用了所有类型。如果有的类型没用，你可以禁用它们。</p>
<p><span style="color: #888888;">Finally, the&nbsp;<code>pfnUserCallback</code>&nbsp;field specifies the pointer to the callback function. You can optionally pass a pointer to the&nbsp;<code>pUserData</code>&nbsp;field which will be passed along to the callback function via the&nbsp;<code>pUserData</code>&nbsp;parameter. You could use this to pass a pointer to the&nbsp;<code>HelloTriangleApplication</code>&nbsp;class, for example.</span></p>
<p>最后，<code>pfnUserCallback</code>&nbsp;字段标明回调函数的指针。你可以（可选地）向<code>pUserData</code>&nbsp;字段传入一个指针，它会随着<code>pUserData</code>&nbsp;参数传给回调函数。例如，你可以用它传入一个<code>HelloTriangleApplication</code>&nbsp;类的指针。</p>
<p><span style="color: #888888;">Note that there are many more ways to configure validation layer messages and debug callbacks, but this is a good setup to get started with for this tutorial. See the&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_debug_utils"><span style="color: #888888;">extension specification</span></a>&nbsp;for more info about the possibilities.</span></p>
<p><span style="color: #000000;">注意，还有很多其他方式，可以配置验证层消息和debug回调函数，但是在本教程中用这样的方式是个好的开始。参考扩展说明&nbsp;可得更多可能的信息。</span></p>
<p><span style="color: #888888;">This struct should be passed to the&nbsp;<code>vkCreateDebugUtilsMessengerEXT</code>&nbsp;function to create the&nbsp;<code>VkDebugUtilsMessengerEXT</code>&nbsp;object. Unfortunately, because this function is an extension function, it is not automatically loaded. We have to look up its address ourselves using&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><span style="color: #888888;"><code>vkGetInstanceProcAddr</code></span></a>. We're going to create our own proxy function that handles this in the background. I've added it right above the&nbsp;<code>HelloTriangleApplication</code>&nbsp;class definition.</span></p>
<p>这个struct应当被传入<code>vkCreateDebugUtilsMessengerEXT</code>&nbsp;函数，以创建<code>VkDebugUtilsMessengerEXT</code>&nbsp;对象。不幸的是，因为这个函数是个扩展函数，它不是被自动加载的。我们不得不用<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkGetInstanceProcAddr</code></a>函数自己查找它的地址。我们要创建自己的代理函数来在后台处理这件事。我已经将它放到<code>HelloTriangleApplication</code>&nbsp;类定义的上面。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, <span style="color: #0000ff;">const</span> VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, <span style="color: #0000ff;">const</span> VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*<span style="color: #000000;"> pDebugMessenger) {
</span><span style="color: #008080;">2</span>     auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, <span style="color: #800000;">"</span><span style="color: #800000;">vkCreateDebugUtilsMessengerEXT</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">3</span>     <span style="color: #0000ff;">if</span> (func !=<span style="color: #000000;"> nullptr) {
</span><span style="color: #008080;">4</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> func(instance, pCreateInfo, pAllocator, pDebugMessenger);
</span><span style="color: #008080;">5</span>     } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
</span><span style="color: #008080;">6</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> VK_ERROR_EXTENSION_NOT_PRESENT;
</span><span style="color: #008080;">7</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">8</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">The&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><span style="color: #888888;"><code>vkGetInstanceProcAddr</code></span></a>&nbsp;function will return&nbsp;<code>nullptr</code>&nbsp;if the function couldn't be loaded. We can now call this function to create the extension object if it's available:</span></p>
<p>如果函数不能被加载，<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkGetInstanceProcAddr</code></a>&nbsp;函数会返回<code>nullptr</code>&nbsp;。我们现在可以调用这个函数来创建扩展对象了（如果可用的话）。</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">if</span> (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, nullptr, &amp;debugMessenger) !=<span style="color: #000000;"> VK_SUCCESS) {
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">throw</span> std::runtime_error(<span style="color: #800000;">"</span><span style="color: #800000;">failed to set up debug messenger!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">3</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">The second to last parameter is again the optional allocator callback that we set to&nbsp;<code>nullptr</code>, other than that the parameters are fairly straightforward. Since the debug messenger is specific to our Vulkan instance and its layers, it needs to be explicitly specified as first argument. You will also see this pattern with other&nbsp;<em>child</em>&nbsp;objects later on. Let's see if it works... Run the program and close the window once you're fed up with staring at the blank window. You'll see that the following messages are printed to the command prompt:</span></p>
<p>第二个到最后一个参数，又是可选的分配器回调函数，我们设置为<code>nullptr</code>即可，除此之外，其他参数都很直观。由于debug信使是我们的Vulkan instance及其层专用的，它需要被显式地标明为第一个参数。你将在其他子对象上也看到这样的模式。我们看看它能否工作。运行程序，一旦出现空窗口就关闭窗口。你将看到下述信息打印到命令行：</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/383191/201906/383191-20190623195532459-2036894182.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="color: #888888;">If you don't see any messages then&nbsp;<a href="https://vulkan.lunarg.com/doc/view/1.1.106.0/windows/getting_started.html#user-content-verify-the-installation"><span style="color: #888888;">check your installation</span></a>.</span></p>
<p>如果你没有看到任何消息，那么检查你的安装过程。</p>
<p><span style="color: #888888;">Oops, it has already spotted a bug in our program! The&nbsp;<code>VkDebugUtilsMessengerEXT</code>&nbsp;object needs to be cleaned up with a call to&nbsp;<code>vkDestroyDebugUtilsMessengerEXT</code>. Similarly to&nbsp;<code>vkCreateDebugUtilsMessengerEXT</code>&nbsp;the function needs to be explicitly loaded. Note that it is normal for this message to be printed multiple times. This happens because multiple validation layers check for the deletion of the debug messenger.</span></p>
<p>哎呀，它点出了我们程序中的一个bug！<code>VkDebugUtilsMessengerEXT</code>&nbsp;对象需要被<code>vkDestroyDebugUtilsMessengerEXT</code>函数清理。与<code>vkCreateDebugUtilsMessengerEXT</code>&nbsp;相似，这个函数需要被显式地加载。注意，如果这个消息被打印很多次，那是很正常的。这是因为多个验证层检查了debug信使的删除操作。</p>
<p><span style="color: #888888;">Create another proxy function right below&nbsp;<code>CreateDebugUtilsMessengerEXT</code>:</span></p>
<p>在<code>CreateDebugUtilsMessengerEXT</code>下面创建另一个代理函数：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">void</span> DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, <span style="color: #0000ff;">const</span> VkAllocationCallbacks*<span style="color: #000000;"> pAllocator) {
</span><span style="color: #008080;">2</span>     auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, <span style="color: #800000;">"</span><span style="color: #800000;">vkDestroyDebugUtilsMessengerEXT</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">3</span>     <span style="color: #0000ff;">if</span> (func !=<span style="color: #000000;"> nullptr) {
</span><span style="color: #008080;">4</span> <span style="color: #000000;">        func(instance, debugMessenger, pAllocator);
</span><span style="color: #008080;">5</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">6</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">Make sure that this function is either a static class function or a function outside the class. We can then call it in the&nbsp;<code>cleanup</code>&nbsp;function:</span></p>
<p>确保这个函数要么是个静态类函数，要么是类外部的函数。然后我们可以在<code>cleanup</code>&nbsp;函数里调用它：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> cleanup() {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">if</span><span style="color: #000000;"> (enableValidationLayers) {
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">        DestroyDebugUtilsMessengerEXT(instance, debugMessenger, nullptr);
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 5</span>  
<span style="color: #008080;"> 6</span> <span style="color: #000000;">    vkDestroyInstance(instance, nullptr);
</span><span style="color: #008080;"> 7</span>  
<span style="color: #008080;"> 8</span> <span style="color: #000000;">    glfwDestroyWindow(window);
</span><span style="color: #008080;"> 9</span>  
<span style="color: #008080;">10</span> <span style="color: #000000;">    glfwTerminate();
</span><span style="color: #008080;">11</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">When you run the program again you'll see that the error message has disappeared. If you want to see which call triggered a message, you can add a breakpoint to the message callback and look at the stack trace.</span></p>
<p>当你再次运行程序时，你会看到错误消息消失了。如果你想看看，是什么触发了消息，你可以添加一个断点到消息回调函数，观察stack trace。</p>
<h1>Debugging instance creation and destruction 调试instance的创建过程和销毁过程</h1>
<p><span style="color: #888888;">Although we've now added debugging with validation layers to the program we're not covering everything quite yet. The&nbsp;<code>vkCreateDebugUtilsMessengerEXT</code>&nbsp;call requires a valid instance to have been created and&nbsp;<code>vkDestroyDebugUtilsMessengerEXT</code>&nbsp;must be called before the instance is destroyed. This currently leaves us unable to debug any issues in the&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html"><span style="color: #888888;"><code>vkCreateInstance</code></span></a>&nbsp;and&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkDestroyInstance.html"><span style="color: #888888;"><code>vkDestroyInstance</code></span></a>&nbsp;calls.</span></p>
<p>尽管我们现在加入了用验证层进行调试的功能，我们还没有搞定所有问题。<code>vkCreateDebugUtilsMessengerEXT</code>&nbsp;函数要求一个有效的instance已经创建完毕，<code>vkDestroyDebugUtilsMessengerEXT</code>&nbsp;必须在instance销毁之前调用。这让我们无法在<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>&nbsp;和<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkDestroyInstance.html"><code>vkDestroyInstance</code></a>&nbsp;的调用中调试任何问题。</p>
<p><span style="color: #888888;">However, if you closely read the&nbsp;<a href="https://github.com/KhronosGroup/Vulkan-Docs/blob/master/appendices/VK_EXT_debug_utils.txt#L120"><span style="color: #888888;">extension documentation</span></a>, you'll see that there is a way to create a separate debug utils messenger specifically for those two function calls. It requires you to simply pass a pointer to a&nbsp;<code>VkDebugUtilsMessengerCreateInfoEXT</code>&nbsp;struct in the&nbsp;<code>pNext</code>&nbsp;extension field of&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkInstanceCreateInfo.html"><span style="color: #888888;"><code>VkInstanceCreateInfo</code></span></a>. First extract population of the messenger create info into a separate function:</span></p>
<p>但是，如果你仔细阅读扩展文档，你会看到有个办法可以专门为这2个函数创建一个单独的debug工具信使。它要求你向<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>的<code>pNext</code>&nbsp;扩展字段传入一个<code>VkDebugUtilsMessengerCreateInfoEXT</code>&nbsp;结构体。首先提取信使创建信息到一个单独函数：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span> populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT&amp;<span style="color: #000000;"> createInfo) {
</span><span style="color: #008080;"> 2</span>     createInfo =<span style="color: #000000;"> {};
</span><span style="color: #008080;"> 3</span>     createInfo.sType =<span style="color: #000000;"> VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
</span><span style="color: #008080;"> 4</span>     createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |<span style="color: #000000;"> VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
</span><span style="color: #008080;"> 5</span>     createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |<span style="color: #000000;"> VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
</span><span style="color: #008080;"> 6</span>     createInfo.pfnUserCallback =<span style="color: #000000;"> debugCallback;
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 8</span>  
<span style="color: #008080;"> 9</span> <span style="color: #000000;">...
</span><span style="color: #008080;">10</span>  
<span style="color: #008080;">11</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setupDebugMessenger() {
</span><span style="color: #008080;">12</span>     <span style="color: #0000ff;">if</span> (!enableValidationLayers) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">13</span>  
<span style="color: #008080;">14</span> <span style="color: #000000;">    VkDebugUtilsMessengerCreateInfoEXT createInfo;
</span><span style="color: #008080;">15</span> <span style="color: #000000;">    populateDebugMessengerCreateInfo(createInfo);
</span><span style="color: #008080;">16</span>  
<span style="color: #008080;">17</span>     <span style="color: #0000ff;">if</span> (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, nullptr, &amp;debugMessenger) !=<span style="color: #000000;"> VK_SUCCESS) {
</span><span style="color: #008080;">18</span>         <span style="color: #0000ff;">throw</span> std::runtime_error(<span style="color: #800000;">"</span><span style="color: #800000;">failed to set up debug messenger!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">20</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">We can now re-use this in the&nbsp;<code>createInstance</code>&nbsp;function:</span></p>
<p>现在我们可以在<code>createInstance</code>&nbsp;函数中复用它：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> createInstance() {
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">    ...
</span><span style="color: #008080;"> 3</span>  
<span style="color: #008080;"> 4</span> <span style="color: #000000;">    VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo;
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">if</span><span style="color: #000000;"> (enableValidationLayers) {
</span><span style="color: #008080;"> 6</span>         createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;<span style="color: #000000;">(validationLayers.size());
</span><span style="color: #008080;"> 7</span>         createInfo.ppEnabledLayerNames =<span style="color: #000000;"> validationLayers.data();
</span><span style="color: #008080;"> 8</span>  
<span style="color: #008080;"> 9</span> <span style="color: #000000;">        populateDebugMessengerCreateInfo(debugCreateInfo);
</span><span style="color: #008080;">10</span>         createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*) &amp;<span style="color: #000000;">debugCreateInfo;
</span><span style="color: #008080;">11</span>     } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
</span><span style="color: #008080;">12</span>         createInfo.enabledLayerCount = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">13</span>         
<span style="color: #008080;">14</span>         createInfo.pNext =<span style="color: #000000;"> nullptr;
</span><span style="color: #008080;">15</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">16</span>  
<span style="color: #008080;">17</span> <span style="color: #000000;">    ...
</span><span style="color: #008080;">18</span> }</pre>
</div>
<p>&nbsp;</p>
<p><span style="color: #888888;">The&nbsp;<code>debugCreateInfo</code>&nbsp;variable is placed outside the if statement to ensure that it is not destroyed before the&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html"><span style="color: #888888;"><code>vkCreateInstance</code></span></a>&nbsp;call. By creating an additional debug messenger this way it will automatically be used during&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html"><span style="color: #888888;"><code>vkCreateInstance</code></span></a>&nbsp;and&nbsp;<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkDestroyInstance.html"><span style="color: #888888;"><code>vkDestroyInstance</code></span></a>&nbsp;and cleaned up after that.</span></p>
<p>变量<code>debugCreateInfo</code>&nbsp;被置于if语句之外，以确保它在<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>&nbsp;调用之前不会被销毁。通过以这样的方式创建一个额外的debug信使，它会被自动地用在<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>&nbsp;和<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkDestroyInstance.html"><code>vkDestroyInstance</code></a>&nbsp;中，且在那之后被清理掉。</p>
<h1>Configuration 配置</h1>
<p><span style="color: #888888;">There are a lot more settings for the behavior of validation layers than just the flags specified in the&nbsp;<code>VkDebugUtilsMessengerCreateInfoEXT</code>&nbsp;struct. Browse to the Vulkan SDK and go to the&nbsp;<code>Config</code>&nbsp;directory. There you will find a&nbsp;<code>vk_layer_settings.txt</code>&nbsp;file that explains how to configure the layers.</span></p>
<p>除在<code>VkDebugUtilsMessengerCreateInfoEXT</code>&nbsp;结构体中标明的flag外，严重层的行为配置项还有很多。浏览Vulkan SDK，找到<code>Config</code>&nbsp;文件夹。在这里你会发现一个<code>vk_layer_settings.txt</code>&nbsp;文件，它解释了如何配置层。</p>
<p><span style="color: #888888;">To configure the layer settings for your own application, copy the file to the&nbsp;<code>Debug</code>&nbsp;and&nbsp;<code>Release</code>&nbsp;directories of your project and follow the instructions to set the desired behavior. However, for the remainder of this tutorial I'll assume that you're using the default settings.</span></p>
<p>为了给你的app配置层，将此文件复制到你项目的<code>Debug</code>&nbsp;和<code>Release</code>&nbsp;文件夹下，遵循其指示来设置你想要的行为。然而，在本教程最后，我将假设你在使用默认配置。</p>
<p><span style="color: #888888;">Throughout this tutorial I'll be making a couple of intentional mistakes to show you how helpful the validation layers are with catching them and to teach you how important it is to know exactly what you're doing with Vulkan. Now it's time to look at&nbsp;<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Physical_devices_and_queue_families"><span style="color: #888888;">Vulkan devices in the system</span></a>.</span></p>
<p>在本教程中我将故意弄几个内部错误，以展示验证层对于捕捉错误的益处，以及懂得你在用Vulkan时保持头脑清楚的重要性。现在是时候看一下系统中的Vulkan设备了。</p>
<p><a href="https://vulkan-tutorial.com/code/02_validation_layers.cpp">C++ code</a> C++完整源代码</p>
<ul>
<li><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Instance">Previous</a>上一章</li>
</ul>
<p align="center">&nbsp;</p>
<ul>
<li><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Physical_devices_and_queue_families">Next</a>下一章</li>
</ul>
<p>&nbsp;</p>